#!/usr/bin/env python3
"""
extract_symbols.py - Extract symbol table from RISC-V ELF files

Generates a Verilog-compatible symbol map for debug tracing.
Usage: ./extract_symbols.py <elf_file> [output_file]
"""

import sys
import subprocess
import re
from collections import namedtuple

Symbol = namedtuple('Symbol', ['addr', 'type', 'name'])

def extract_symbols_from_elf(elf_path):
    """Extract symbols using riscv64-unknown-elf-nm"""
    try:
        # Run nm to get symbol table (without -S for compatibility)
        result = subprocess.run(
            ['riscv64-unknown-elf-nm', '-n', elf_path],
            capture_output=True, text=True, check=True
        )

        symbols = []
        for line in result.stdout.strip().split('\n'):
            if not line:
                continue

            # Parse nm output: address type name
            # Example: 00000120 T main
            parts = line.split()
            if len(parts) >= 3:
                addr = int(parts[0], 16)
                sym_type = parts[1]
                name = parts[2]

                # Filter for function symbols (T, t, W, w)
                if sym_type in ['T', 't', 'W', 'w']:
                    symbols.append(Symbol(addr, sym_type, name))

        return sorted(symbols, key=lambda s: s.addr)

    except subprocess.CalledProcessError as e:
        print(f"Error running nm: {e}", file=sys.stderr)
        return []
    except FileNotFoundError:
        print("Error: riscv64-unknown-elf-nm not found", file=sys.stderr)
        return []

def generate_verilog_symbol_map(symbols, output_file):
    """Generate Verilog function to lookup symbol names"""

    with open(output_file, 'w') as f:
        f.write("// Auto-generated symbol map\n")
        f.write("// Generated by extract_symbols.py\n\n")

        f.write("function [1023:0] symbol_lookup;\n")
        f.write("  input [31:0] addr;\n")
        f.write("  begin\n")
        f.write("    case (addr)\n")

        for sym in symbols:
            # Truncate long names, escape special characters
            name = sym.name[:64]  # Max 64 chars
            f.write(f"      32'h{sym.addr:08x}: symbol_lookup = \"{name}\";\n")

        f.write("      default: symbol_lookup = \"<unknown>\";\n")
        f.write("    endcase\n")
        f.write("  end\n")
        f.write("endfunction\n")

def generate_text_symbol_map(symbols, output_file):
    """Generate simple text file with symbols"""
    with open(output_file, 'w') as f:
        f.write("# Symbol Map\n")
        f.write("# Address    Type  Name\n")
        for sym in symbols:
            f.write(f"0x{sym.addr:08x}  {sym.type:1s}     {sym.name}\n")

def generate_gdb_script(symbols, output_file):
    """Generate GDB-style symbol info for easy lookup"""
    with open(output_file, 'w') as f:
        f.write("# GDB-style symbol map\n")
        for i, sym in enumerate(symbols):
            if i < len(symbols) - 1:
                size = symbols[i+1].addr - sym.addr
            else:
                size = 0
            f.write(f"0x{sym.addr:08x} - 0x{sym.addr+size:08x} : {sym.name}\n")

def main():
    if len(sys.argv) < 2:
        print("Usage: extract_symbols.py <elf_file> [output_base]")
        print("  Generates: output_base.vh (Verilog), output_base.txt (text), output_base.sym (GDB-style)")
        sys.exit(1)

    elf_path = sys.argv[1]

    if len(sys.argv) >= 3:
        output_base = sys.argv[2]
    else:
        # Default: use ELF filename without extension
        output_base = elf_path.rsplit('.', 1)[0]

    print(f"Extracting symbols from {elf_path}...")
    symbols = extract_symbols_from_elf(elf_path)

    if not symbols:
        print("No symbols found or error occurred")
        sys.exit(1)

    print(f"Found {len(symbols)} function symbols")

    # Generate all output formats
    verilog_file = f"{output_base}_symbols.vh"
    text_file = f"{output_base}_symbols.txt"
    sym_file = f"{output_base}_symbols.sym"

    generate_verilog_symbol_map(symbols, verilog_file)
    print(f"Generated Verilog map: {verilog_file}")

    generate_text_symbol_map(symbols, text_file)
    print(f"Generated text map: {text_file}")

    generate_gdb_script(symbols, sym_file)
    print(f"Generated symbol map: {sym_file}")

    # Display first few symbols
    print("\nFirst 10 symbols:")
    for sym in symbols[:10]:
        print(f"  0x{sym.addr:08x}  {sym.type}  {sym.name}")

if __name__ == '__main__':
    main()
